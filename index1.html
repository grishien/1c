Создал(а) Баранов Дмитрий Сергеевич 04 окт., 2023
Характеристики обмена
Структура передаваемого объекта
Обработка данных
Синхронный обмен
Односторонний обмен
Синхронизация с контролем доставки и без
Событийный\не событийный обмен
Ручной обмен
Автоматический обмен
Способы регистрации
Регистрация изменений в дополнительные таблицы с ключами на данные
Дополнительное поле отметка
Регистрация данных интервалами значений
Регистрация данных в дополнительной таблице с версиями.
Регистрация данных полной таблицей
Выгрузка результатом запросом
Транспорт
Прямая передача
Передача через посредников
Выгрузка в файлы
Требования к обмену
Примеры реализаций
Базовый обмен
Отправка таблицы настройки потоков
Механизм "универсальная очередь данных"
В аттестациях одним из первых вопросов по базовому обмену является "Что такое базовый обмен"?
На этот вопрос можно отвечать по разному: что это план обмена "базовый", или наш "первый самописный" обмен, или это просто свод правил заключенных в этот термин, некоторая абстракция. 
Наверное, стоит перефразировать его и пойти к истокам образования базового обмена и задать вопрос, а зачем разделять базу данных так, чтобы потом "лепить" какой-то базовый обмен.

Давайте попробуем выявить причины разделения одной базы на несколько. В чём неудобна одна база:

Единая база данных является точкой отказа. Действительно если работать только в одной базе, то при первом же отключении света или её недоступность/обслуживании работа в компании прекратилась до восстановления работоспособности этой базы.
Высокая конкуренция за ресурсы. Тут стоит разделять серверные ресурсы (агент, рабочие сервера, СУБД) и конкуренцию за ресурсы на уровне строк/таблиц базы данных. 
Высокая связность приложений. Можно изменять какие-то данные, но косвенно влиять на другие, как на логическом уровне, так и на уровне доступности этих данных.
Обслуживание. Практически нереально реструктуризовать большие таблицы, а также реиндексировать большие таблицы. Большие таблицы - боль. В одной большой базе, много больших таблиц.
Разделение данных. Необходимо продумывать логику разделения, например, регион везде первым полем в индексе. Звучит страшно.
Геораспределённость пользователей. Что приводит к медленной работе одной базы, которая географически далеко расположена от части пользователей.
Несомненно, если покопаться, можно найти еще кучу минусов, а также плюсов работы в одной системе (базе) всех пользователей сразу. Но совокупность всех минусов даёт понимание, что базу необходимо разбивать, а данные синхронизировать. Пройдемся по различным подходам к синхронизации данных. 

Характеристики обмена
Есть ряд характеристик, комбинируя которые в зависимости от требований, можно построить обмен подходящий под нужды заказчика.

Структура передаваемого объекта
Существует два подхода к передачи объекта:

Передача полного слепка объекта
Передача изменений произошедших с объектом
В каждом из данных подходов есть свои плюсы и минусы.

При "полной передаче" достаточно просто зафиксировать изменения, но при этом пакет обмена содержит все данные каждого объекта (а то и нескольких его версий), что иногда избыточно. Соответственно, такую модель стоит использовать в тех ситуациях, когда в объектах часто меняются несколько свойств, либо когда их немного. Особое внимание нужно обратить на поля сложных (тяжёлых) типов, вроде JSON, Двоичные данные, Неограниченная строка и т.д.

При "передаче изменений" усложняется логика формирования изменений — необходимо определить какие поля изменились. Несомненным плюсом является то, что уменьшается объем передаваемой информации, а также существует возможность точечного обновления объекта на стороне приемника в случае, когда в разных системах единовременно произошло изменение одного и того же объекта по разным полям, при передаче изменений от каждой базы получится сохранить оба этих изменения.

При "полной модели" мы, скорее всего, потеряем одно из изменений, так как последовательно перезапишем объект разными состояниями.

В 1С по умолчанию используется передача полного слепка объекта.

Обработка данных
Обменивающиеся системы должны быть согласованы по формату сообщения.
Это может быть строгая типизация, например схема XML или же менее формальное, обычная договоренность между разработчиками.
Есть два основных подхода:

Когда данные перед записью в целевой базе обрабатываются в промежуточной базе/хранилище (ETL)
Когда данные сразу загружаются в целевую базу, а уже потом происходят преобразования (ELT) 
Синхронный обмен
При синхронной обработке систем одна из них взаимодействует "напрямую" и ждёт ответа от другой системы.
В основном используется, когда необходимо гарантированно и быстро изменить данные в приёмнике.
Приложение должно быть заточено больше на синхронизацию данных.

Асинхронная реакция позволяет запустить логику синхронизации в другом потоке, который практически не влияет на основной поток изменения объекта.
Можно создать очередь, в которую будут сливаться объекты, которые когда-нибудь надо будет отправить в другую систему.

Односторонний обмен
При одностороннем обмене информация передается только от одной системы к другой.
При двустороннем обмене обе системы будут как источниками, так и приёмниками пакетов обмена.

Синхронизация с контролем доставки и без
Под гарантией доставки сообщения понимается, что система, которая отправила сообщение, знает, что приёмник успешно обработал данные.
Важен сам факт обработки, ведь в базе отправителя надо почистить регистрацию изменений.
Это можно организовать как ответным сообщением от базы приёмника - "квитирование", так и прямым запросом от отправителя к приемнику для получения этой информации.
При доставке без гарантии база отправитель может лишь предполагать, что база получатель получила и обработала данные, либо это не существенно.

Событийный\не событийный обмен
В основном, под событийным обменом понимается передача изменений объекта сразу после событий, связанных с его изменением состояния (добавления/обновления/удаления).
В микро-сервисной архитектуре события могут быть не привязаны к конкретному объекту, а описывать какие-то общие состояния, например изменение статуса и т.д.
К не событийному относят любой из способов обмена, который не завязан на попытку доставки изменений сразу после события изменения объекта.
Обычно это периодическую выгрузка по времени, через очереди.

Ручной обмен
Человек вручную запускает каждую итерацию обмена.

Автоматический обмен
Заданный по определённым условиям обмен без непосредственного участия человека.

Способы регистрации
Регистрация изменений в дополнительные таблицы с ключами на данные
При записи объекта любое изменение его состояния необходимо фиксировать в дополнительную таблицу, по которой в дальнейшем будет происходить вычисление, что нужно отправить на обмен.
Как одной из простейших реализаций — при каждом событии объекта делать запись в дополнительную таблицу.
В 1С существует своя автоматическая реализация фиксаций изменений, построенная на объекте "План обмена". При записи объекта 1С в транзакции фиксирует ключи измененных данных в предопределенный объект — таблицу изменений.

В MSSQL есть инструмент "Change Tracking", который создаёт дополнительные таблицы на стороне СУБД.

Если хранить промежуточные ключи, то потом при выгрузке можно будет получить по этим отборам реальные данные.
Хранить такую информацию удобнее, чем весь объект, но при нескольких изменениях можно получить только последнюю версию.

К плюсам этого способа можно приписать следующие:

гибкие возможности хранения информации по изменениям
не требует изменения структуры основных таблиц
возможность отслеживать удаление записей
возможность регистрировать данные без перезаписи основной таблицы
подходит для регистрации практически любых данных
Минусы

дополнительное место на диске под техническую таблицу
замедление транзакции записи данных
возможны дополнительные блокировки
возможны коллизии при двустороннем обмене
обслуживание и контроль дополнительных таблиц
может присутствовать зависимость от изменения структуры основных таблиц
Дополнительное поле отметка
В целевой таблице создается дополнительное поле, которое отвечает за факт изменения записи.
Можно сделать это поле типа "булево", например, "надо отправить" и при изменении объекта выставлять галочку в истину, а при ответе от приёмника сбрасывать "надо отправить" в ложь.
Для того чтобы не потерять изменения еще не отправленных объектов, необходимо знать, с каких объектов снимать эту галочку. Для этого в ответном сообщении нужно передавать ключи от источника к приёмнику снова.

Но предположим, что после изменения объекта и выставления флага "надо отправить", произошла отправка пакета обмена во вторую систему. А после этого сделали ещё несколько операций модифицирования этих же данных.
В результате, когда придёт ответный пакет с подтверждением успешной записи, первая система переведёт значение флага "надо отправить" в ложь, и мы не отправим измененные объекты другую систему, т.е потеряем факт изменения состояния объектов.
Поэтому может потребоваться какая-то вспомогательная структура, либо более сложный тип для "флага".

К плюсам этого способа можно приписать следующие:

экономия места в следствие отказа от дополнительной таблицы с ключами
время транзакции не увеличивается 
подходит для регистрации любых данных
подходит для данных с большим количеством изменений
прост в реализации и понимании
позволяет при необходимости менять объём порции выгрузки
Минусы:

невозможность отследить удаление записи
возможна потеря состояния изменений
нет возможности отправки без изменений основной таблицы
высокая конкуренция к строкам основной таблицы
нет возможности отправлять данные больше чем одному получателю, либо это будет страшно выглядеть, типа строки "(1;0;0;2)" - этому отправить, этому не надо, этому не надо, этому отправили
избыточность данных при формировании сообщения обмена
изменение структуры основной таблицы для добавления поля
Регистрация данных интервалами значений
Существует другой подход, где на основе дополнительного поля при выгрузке проверяется, попадает ли объект в заданный интервал и, если это условие выполняется, то он выгружается.
Добавим дополнительное поле с отметкой текущего времени, например, дата-время последнего изменения объекта.
При такой реализации необходимо сделать одну дополнительную таблицу, в которой будет хранится значение для каждого получателя и время последней синхронизации.

Можно представить такой обмен следующим образом, основная таблица:

00001	Телевизор	01.09.2023 09:30:00
00002	Тостер	01.09.2023 10:20:00
Таблица с дополнительными данными. Предположим, что мы делаем первую итерацию обмена, поэтому время синхронизации будет "пустая дата".

Получатель 1	01.01.2001 00:00:00
Получатель 2	01.01.2001 00:00:00
При выгрузке к подчиненному, например, получатель 1,  выберем из таблицы с объектами все, у которых время записи попадает в интервал между последней синхронизацией (01.01.2001 00:00:00) и текущей датой, как пример, (01.09.2023 10:30).
По условию будут выгружены два объекта с номерами 00001 и 00002, также в базу приемника необходимо передать значение текущей даты на момент выгрузки (01.09.2023 10:30). Эта дата будет некоторой квитанцией. 
Когда придет ответный пакет, база приемника передаст нам в ответном пакете дату квитанции, которую мы обновим в дополнительной таблице (01.09.2023 10:30)

Получатель 1	01.09.2023 10:30
Получатель 2	01.01.2001 00:00:00
В следующей итерации выгрузки будут выбраны все объекты между 01.09.2023 10:30 и текущая дата.
В целом, для обмена построенного на интервалах не обязательно, чтобы дополнительное поле было именно датой, это могут быть и интервалы ключей (ИД-шников), просто с датой все логически понятно.
Также не обязательно, чтобы верхняя граница была именно текущая дата. Можно заложить логику, при которой верхняя граница будет более статичная, например, время последней синхронизации + 10 секунд, тем самым позволив регулировать средний размер порции выгрузки данных.

Плюсы:

время транзакции не увеличивается 
подходит для данных с большим количеством изменений
прост в реализации и понимании
Минусы:

невозможность отследить удаление записи
потребуется дополнительная техническая колонка, если нет колонки на которой можно построить логики интервалов
нужен какой-то признак, по которому можно построить упорядоченный интервал т.е подходит не для всех таблиц
возможна потеря состояния изменений (К сожалению, даже при этом способе есть риск потери изменений, если они были сделаны в том интервале, который уже отправили на обмен
нет возможности отправки без изменений основной таблицы
высокая конкуренция к строкам основной таблицы
нет возможности отправлять данные больше чем одному получателю
избыточность данных при формировании сообщения обмена
изменение структуры основной таблицы для добавления поля 
Регистрация данных в дополнительной таблице с версиями.
В данной реализации в дополнительной таблице хранятся полные версии измененного объекта или его промежуточные изменения.

В классических системах регистрируются именно изменения по версиям, т.е. в таблице регистрации изменений на один объект существует столько записей, сколько раз мы его меняли. Версией может быть что угодно. Это может быть весь объект, либо только те поля, которые изменились.
Есть системы регистрации вообще без данных, где регистрируется просто факт того, что эта ссылка менялась, а данные берутся из основной таблицы. В отличии от таблиц изменений 1с в таблицу регистрации изменений всегда падает новая запись – производится INSERT, вместо UPDATE, который никем не блокируется, ему никто не мешает, и он всегда фиксируется. Роль фиксации изменений ни с кем не конкурирует, она сама по себе.

Если логика обмена основана на сохранении частичных изменений объекта: отправитель фиксирует версии (возможно в дополнительной таблице), которые отправил ранее, и при следующей отправке выбирает все изменения выше зафиксированной версии. При этом отправитель может свернуть изменения всех не отправленных версий, для того чтобы получить текущие состояние объекта.

В системах, где используется сохранение всего слепка объекта, каждая версия отправляется отдельно и применяется к целевой системе по порядку.
Удаление происходит следующим образом: из таблицы удаляются все версии ниже фиксированной. Он ни с кем не конкурирует, никому не мешает.

В классике это разводят вот так – все три роли не конкурируют, и все работает.
С другой стороны, если хранить полные версии объекта, объем данных получается больше, потому что нужно больше места для регистрации версий.
Если хранить частичные изменения, то системы несут издержки на поиск того что изменилось.
Это плата за решение проблемы блокировок.

Примеры реализаций:

В БСП есть подсистема «Версионирование объектов».
В 1С энтузиасты рассматривают механизм "историю данных" в качестве таблицы очереди. 
Плюсы:

отсутствие блокировок
синхронизация только теми данными, которые реально менялись, минимум лишнего
возможно отслеживать удаление объектов
Минусы:

избыточное хранение всех версий строк
издержки при записи транзакции
сложная логика при сохранения версий
чувствительно к изменению структуры основных объектов 
Регистрация данных полной таблицей
При данной реализации таблица уходит на обмен целиком. 
Программист сам решает, в какой момент необходимо отдать всю таблицу,  можно хранить в дополнительной таблице факт изменения или выгружать периодически. 
Данные обмен очень зависит от размера таблицы.
Как правило в такой реализации используется односторонний обмен, база отправитель хранит эталонные данные, которые должны быть в приемнике. 
Например, для такой реализации подходит передача каких-то настроек.

Плюсы:

простая логика
возможно отслеживать удаление объектов
удаление записей можно проверить на стороне приёмника
не требует изменения архитектуры системы-источника
отсутствие блокировок в процессе обмена
не влияет на транзакцию записи основных объектов 
не требует очистки предыдущей регистрации
Минусы:

подходит для решения специфических задач
часто избыточный объём миграции данных
нет понимания, что именно изменилось
Выгрузка результатом запросом
При данной реализации отсутствуют регистрация изменений как таковая.
Происходит периодическая выгрузка, основанная на результате выборки.
Например, нужно выгрузить информацию на сайт, где одна сущность в системе-приёмнике состоит из 3х связных объектов в источнике, но в системе сайта не нужны все эти три объекта.
Поэтому мы можем в источнике сделать запрос с соединением и выгрузить структуру, которую ожидает сайт.

Плюсы:

не требует изменения архитектуры системы-источника
не требует очистки предыдущей регистрации
не влияет на транзакцию записи основных объектов
отсутствие блокировок в процессе обмена
Минусы:

подходит для решения специфических задач
всё-таки может приводить к изменению архитектуры системы, чтобы запрос мог получить нужные данные
обычно, запросы в таком механизме очень долгие и затратные по ресурсам
при таком алгоритме сложно разбирать проблемы
этот механизм крайне чувствителен к изменению структуры основных таблиц
структура данных должна быть согласована в источнике и приемнике, любое изменение может привести к ошибке
Транспорт
Под транспортом понимается, каким способом данные от источника попадут к приемнику.

Прямая передача
Способы прямой передачи

прямой запрос к СУБД
HTTP-Сервисы
com-объект
web-Socket-ы
API
Передача через прямые запросы присуща синхронному обмену, считается что данных способ один из самых быстрых и гарантированных способов доставки изменений из источника к приемнику.
Однако данный способ очень сильно зависит от доступности приемника. Если организовывать синхронно-событийную модель, то для гарантии отправки при недоступности приемника необходимо либо откатывать транзакцию, либо вносить ключи объекта в дополнительную таблицу для последующей отправки, что в свою очередь приведет к увеличению издержек по синхронизации.
Также важно понимать, что при возрастании количества получателей возрастает время записи объекта и соответственно синхронная отправка для каждого приемника может длится дольше, чем асинхронная отправка.
Важную роль для прямой передачи играет георасположение приемника: чем дальше он от источника, тем дольше время синхронизации.

Плюсы:

в некоторых случаях самая минимальная задержка синхронизации
гарантированная доставка
проста в реализации
при правильном коде минимальная потеря данных
возможность оперативно обработать ответ от приёмника в процессе синхронизации
Минусы:

прямая зависимость от работоспособности обеих систем-участников обмена
высокая зависимость от качества соединения с приёмником
может зависеть от версий ком-объектов и т.д. 
возрастание времени при записи при увеличении количества приемников
усложнение логики при увеличении количества приемников
при прямых запросах к СУБД приемника, требует чтобы источник знал, о метаданных приемника 
Передача через посредников
Обмен происходит с помощью программы-посредника, например, брокера программных сообщений. Примерами таких технологий могут быть RabbitMQ, Kafka, MSMQ, ZeroMQ и др.
Присущ асинхронному подходу, когда издержки по времени не критичны. При таком обмене можно в момент событий объекта помещать изменения в очередь.
В основном посредник занимается маршрутизацией сообщения и можно транслировать сообщения сразу для всех получателей.
Программы посредники в основном являются отказоустойчивыми с целым кластером страхующих машин.
Проблема с географической удалённостью приемника решается так: машину кластера программы-посредника можно развернуть в подсети источника и помещать сообщение с минимальными сетевыми издержками и, следовательно, минимальным временем транзакции. Передача между машинами кластера уже задача программы-посредника.
По заявлению разработчиков программ-посредников, доставка является гарантированной, но это доставка до сервисной шины, мы не можем гарантировать обработку данных в приемнике. Источник после помещения информации в очередь больше ничего не знает о статусе изменений.

На программах-посредниках можно реализовать гарантированную доставку с квитанцией, но это требует усложнение логики.
Еще несомненным плюсом при асинхронно-событийном подходе является то, что нагрузка на обмен размазывается по времени возникновения событий, а не аккумулируются при выгрузке всех изменений, например, по периоду.   
Существует риск, что если средняя частота возникновения асинхронных событий в системе превышает среднюю частоту отправки объектов синхронизации, то приложение не справится с возрастающим набором необработанных изменений.


Плюс:

Минимальная затраты при записи
Расширенная маршрутизация 
Решена проблема геораспределённости баз
Высокая отказоустойчивость 
На зависит от доступности приемника
Позволяют интегрировать приложения, рассчитанные на различные форматы данных
Минусы:

Ресурсы на разворачивание кластера
Поддержка системы, необходимы специалистов devops
Сложность в администрировании и контроля ошибок
Негарантированная доставка  
Выгрузка в файлы
Этот способ обмена основан на файловом механизме, который является базисом всех современных операционных систем. Главным достоинством обмена файлами является то, что система-источник ничего не должна знать о системах-потребителях. Мы просто формируем файл с данными и выкладываем его в хранилище (например, файловый каталог), где остальные участники интеграционного процесса могут получить из него информацию.
Иногда для обеспечения более надежного обмена файлами приходится явно выделять отдельные регламентные периоды для выгрузки и для загрузки данных, что приводит к временной рассинхронизации интегрируемых систем.

К плюсам интеграции через обмен файлами следует отнести:

Отсутствие строгих связей между интегрируемыми приложениями
Отсутствие необходимости в установке дополнительного программного обеспечения
Общая простота реализации*
Позволяет выгружать довольно большие объёмы данных
*При реализации типового обмена 1С логика на файлах достаточно примитивная, однако её можно значительно усложнять в зависимости от поставленных задач.

К минусам можно отнести:

Монопольная однопоточная запись (1С) 
Неявные блокировки файла другими процессами
Зависимость от работы службы каталогов ОС
Вероятность потери/повреждения файла обмена
Нужно решать проблемы с безопасностью передаваемых данных
Требования к обмену
Прежде чем приступить к реализации какого-либо подхода, нам необходимо ответить на следующие вопросы, касающиеся требований к будущему обмену:

Критичность задержки одной единицы данных по времени
Критичность потери данных 
Доступность других приложений/систем
Необходимо ли реагировать на изменение данных в других приложениях/системах
Достаточно ли передать конечное изменение из целевой базы или нужны все промежуточные состояния объектов?
Есть ли необходимость в передаче связных данных
Важна ли гарантия при передаче данных
Как должны делится данные
Обход коллизий
Влияние на систему
Возможность всех приложений интеграционного контура использовать выбранный способ интеграции
Сетевые издержки
В зависимости от ответов необходимо выполнить следующие действия:

Выбрать процесс синхронизации данных
Выбрать структуру передаваемого сообщения
Выбрать формат передаваемых сообщений
Выбрать реакцию на изменения сущности
Выбрать стратегию деления/маршрутизации данных
Выбрать транспорт для данных
Оценить отказоустойчивость и зависимость от других систем
Оценить влияние на систему 
Оценить безопасность транспортировки сообщения
Оценить сетевые издержки при доставке сообщения
Оценить сложность алгоритма обмена
Примеры реализаций
Базовый обмен
Для данного обмена было определено "зеленое" время задержки между состояниями в 15 мин. Данный обмен асинхронный, потому что успешность выгрузки отправителем не зависит от успешности загрузки получателем. Время указывает на то, что обмен не событийный, а по таймауту.
Потеря данных или рассинхронизация данных выше максимального лимита допустимой задержки (2-3 часа) - является критичной.
В обмене применяется комбинирование различных подходов к регистрации изменений: основной механизм - дополнительные таблицы с ключами на данные, но также существует регистрация данных интервалами значений, например, выгрузка текущих остатков товара.
В основном механизме за структурой дополнительных таблиц и добавлением ключей следит платформа 1С.
Обмен является гарантированным — источник получает от узла-получателя квитанцию о получении нашего сообщения и удаляет регистрацию на ранее отправленные данные.
При выгрузке объекты записываются в XML-файл, пройдя процесс сериализации, и в таком формате данные ждут, пока их заберёт получатель.
В совокупности с распределенным обменом платформа 1С следить за конфигурацией и гарантирует согласованность в структуре таблиц между отправителем и получателем.
При выгрузке была реализована логика фильтрации объектов — если тот не нужен в получателе, то вместо слепка отправляется команда удаления этого объекта.
Транспортом была выбрана выгрузка в файлы. Файлы решают проблему геораспределённости и подходят к передачи большого количества изменений. Логику передачи сообщения в файлах достаточно легко организовать.
Обмен является автоматическим и двусторонним, каждая из баз периодически проверяет наличие файла в общем каталоге для загрузки.
При выгрузке в файлы отсутствует прямая зависимость от состояния получателя, но значительное увеличение накопленных данных в дополнительных таблицах на отправителе может привести к блокировкам и увеличению потребления ресурсов при вставке новых ключей. 
Безопасность сообщения обеспечивается средствами Windows посредством ограниченного доступа на каталоги обмена.
Итерация обмена является ресурсоемкой операцией как для кластера 1С, так и для СУБД.
Из-за риска накопления данных обмен имеет наибольший приоритет по отношению к другим ресурсоемким операциям в базе.
Базовый обмен является более сложной версией типового обмена 1С, некоторые решения были обусловлены высокой нагрузкой на систему. Алгоритм является сложным на всех этапах обмена.
Более подробно о реализации базового обмена можно почитать: Описание работы базового обмена

Отправка таблицы настройки потоков
Для быстрого и удобного редактирования количества потоков чтения базового обмена была реализована обработка и помещена в ЦБ. ЦБ выступает инициатором изменений.
Было принято решение, что изменение потоков должно быть с минимальной задержкой, для этого транспортом выбран прямой HTTP запрос. 
Обмен является ручным и односторонним. 
Обмен является гарантированным, так как мы ожидаем ответ от HTTP-запроса.
Из-за прямого HTTP-запроса обмен является синхронным.
При изменении настроек не происходит регистрации отдельных ключей, а происходит регистрация данных полной таблицей.
Безопасность осуществляется ресурсами HTTP протокола.
Операция обмена не является ресурсоемкой процедурой.
Сложность алгоритма - низкая.

Механизм "универсальная очередь данных"
Механизм универсальная очередь данных (УОД) является некоторым конструктором, где программист при реализации решает:

когда помещать данные в очередь (событийно, периодически по расписанию, в ручную)
каком виде будут хранится данные (полный слепок объекта, лог изменений, ключ, факт изменения, результат запроса)
какой транспорт использовать для передачи (прямой запрос, программа посредник, файл)
Например, можно реализовать событийный обмен: при изменений состояний объекта помещать в очередь полную версию данных и дальше отдельным заданием обработки очереди передавать данные в программу посредника.
Можно отвязаться от событий объекта и делать периодическое помещение результата запроса для дальнейшей передачи, например через HTTP сервис или выгружать данные в файл. 
В некоторых реализациях доставка через очередь не является гарантированной.
Также из-за внутреннего механизма балансировки потоков для отправки нельзя обеспечить какое-то фиксированное время задержки между состояниями объекта.
